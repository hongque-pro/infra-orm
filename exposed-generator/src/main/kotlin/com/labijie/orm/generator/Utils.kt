package com.labijie.orm.generator

import com.google.devtools.ksp.closestClassDeclaration
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.*
import com.labijie.orm.generator.DefaultValues.isConverterMethod
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName
import org.jetbrains.exposed.dao.id.EntityID
import org.jetbrains.exposed.sql.Column
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.net.URL
import java.nio.file.Files
import java.nio.file.Path
import java.util.Enumeration
import java.util.Properties
import kotlin.io.path.Path
import kotlin.io.path.absolutePathString
import kotlin.io.path.createDirectories
import kotlin.io.path.isDirectory
import kotlin.reflect.KClass

fun KSPLogger.println(message: String, symbol: KSNode? = null) {
    this.info("[expose gen] $message", symbol)
}

private fun <T : Any> loadResources(
    name: String, classLoader: ClassLoader?,
    filter: ((InputStream) -> T?)? = null
): T? {
    val systemResources: Enumeration<URL> =
        (classLoader ?: ClassLoader.getSystemClassLoader()).getResources(name)
    while (systemResources.hasMoreElements()) {
        systemResources.nextElement().openStream().use { stream ->
            val content: T? = filter?.invoke(stream)
            return content
        }
    }
    return null
}

private fun getGitProperties(
    packageClass: Class<*>,
    gitPropertiesFile: String = "git-info/git.properties",
): Properties? {
    if (gitPropertiesFile.isBlank()) {
        throw IllegalArgumentException("Git properties file can not be blank.")
    }
    return try {
        loadResources(gitPropertiesFile, packageClass.classLoader) {
            Properties().apply {
                this.load(it)
            }
        }

    } catch (_: IOException) {
        return null
    }
}


private val DEFAULT_CLASS_COMMENTS =
    "This code generated by an open-source project: Infra-Orm \nProject Site: https://github.com/hongque-pro/infra-orm.\n"

fun TypeSpec.Builder.addComments(classComment: String, context: GenerationContext): TypeSpec.Builder {
    val gitProperties = getGitProperties(VisitContext::class.java)
    val comment = CodeBlock.builder()
        .add(classComment)
        .add("\n")
        .add("\n")
        .add(DEFAULT_CLASS_COMMENTS)
        .add("Generator Version: ${gitProperties?.get("git.build.version") ?: "unknown"}\n")
        .add("\n")
        .add("\n")
        .add("Don't modify these codes !!")
        .add("\n")
        .add("\n")
        .add("Origin Exposed Table:")
        .add("\n")
        .add("@see ${context.tableClass.canonicalName}")
        .build()

    return this.addKdoc(comment)

}

private fun KSType.isExposedColumn(): Boolean {
    val isColumnType = this.declaration.qualifiedName?.asString() == Column::class.qualifiedName
    return isColumnType && this.declaration.typeParameters.size == 1
}


fun KSAnnotation.getProperties(): Map<String, Any?> {
    val defaultArgs = this.defaultArguments
    val defaultParams = mutableMapOf<Int, String>()
    defaultArgs.forEachIndexed { index, item ->
        val name = item.name?.getShortName()
        if (!name.isNullOrBlank()) {
            defaultParams[index] = name
        }
    }

    val args = this.arguments
    val parameterValues = mutableMapOf<String, Any?>()
    args.forEachIndexed { index, item ->
        val name = item.name?.getShortName() ?: defaultParams[index]
        if (!name.isNullOrBlank()) {
            parameterValues[name] = item.value
        }
    }
    return parameterValues
}

private fun KSType.getIDTypeFromEntityID(): KSType? {
    if (this.arguments.size != 1) {
        return null
    }
    if (this.declaration.qualifiedName?.asString() != EntityID::class.qualifiedName) {
        return null
    }
    return this.arguments.first().type?.resolve()
}


fun KSPropertyDeclaration.getColumnType(): ColumnType? {

    val propertyType = this.type.resolve()
    val argCount = propertyType.arguments.count()

    if ((argCount == 1)) {

        val col = propertyType.arguments.firstOrNull()
        val columnType = col?.type?.resolve()
        if (columnType != null) {
            val idType = columnType.getIDTypeFromEntityID()
            if (idType != null) {
                return ColumnType(columnType, idType, idType.isMarkedNullable)
            }
            return ColumnType(columnType, columnType, columnType.isMarkedNullable)
        }
    }
    //尽量避免解析
    return null
}

fun KSType.isEnum(): Boolean {
    val classDeclaration = this.declaration as? KSClassDeclaration
    return classDeclaration != null && classDeclaration.classKind == ClassKind.ENUM_CLASS
}

fun <T> KSType.isJavaType(javaClass: Class<T>): Boolean {
    val classDeclaration = this.declaration.qualifiedName?.asString()
    val className = "${javaClass.packageName}.${javaClass.simpleName}"
    return className == classDeclaration
}

fun KSType.isKotlinType(kclass: KClass<*>): Boolean {
    val kType = kclass.asTypeName()
    val projectedType = this.declaration.closestClassDeclaration()?.asStarProjectedType()
    if (projectedType != null && !projectedType.arguments.isEmpty()) return false
    val cls = projectedType?.toClassName()
    if (cls == null) {
        return false
    }
    return kType.compareTo(cls) == 0
}

fun generateParsedValueCodeBlock(valueVarName: String, parseMethod: MemberName?, isNullable: Boolean): CodeBlock {
    return CodeBlock.builder()
        .apply {
            parseMethod?.let {
                if (parseMethod.isConverterMethod()) {
                    addStatement("%T.%N(${valueVarName})", parseMethod.enclosingClassName!!, parseMethod)
                } else {
                    addStatement("${valueVarName}.%N()", parseMethod.simpleName)
                }
            } ?: addStatement(valueVarName)
        }
        .build()
}

fun generateToStringCodeBlock(valueVarName: String, toStringMethod: MemberName?, isNullable: Boolean): CodeBlock {
    return CodeBlock.builder()
        .apply {
            toStringMethod?.let {
                if (toStringMethod.isConverterMethod()) {
                    addStatement(
                        "%T.%N(${valueVarName})",
                        toStringMethod.enclosingClassName!!,
                        toStringMethod.simpleName
                    )
                } else {
                    val toStringBlock = if(isNullable) "(${valueVarName}?.%N()).orEmpty()" else "${valueVarName}.%N()"
                    addStatement(toStringBlock, toStringMethod.simpleName)
                }
            } ?: addStatement(valueVarName)
        }
        .build()
}

fun KSType.isJavaType(qualifiedClassName: String): Boolean {
    val classDeclaration = this.declaration.qualifiedName?.asString()
    return qualifiedClassName == classDeclaration
}


inline fun <reified T> KSType.isJavaType(): Boolean {
    val classDeclaration = this.declaration.qualifiedName?.asString()
    val kotlinClass = T::class.qualifiedName
    return kotlinClass.equals(classDeclaration)
}


fun createFolderIfNotExisted(path: Path) {
    if (!Files.exists(path) || !path.isDirectory()) {
        path.createDirectories()
    }
}

fun buildWriterOptions(env: Map<String, String>): WriterOptions {
    val dir = env.getOrDefault(EnvVariables.POJO_DIR, null)
    if (dir != null && !Path(dir).isAbsolute) {
        throw ExposedGenerationException("`${EnvVariables.POJO_DIR}` must be an absolute path")
    }

    return WriterOptions().apply {
        this.pojoPackageName = env.getOrDefault(EnvVariables.POJO_PACKAGE_NAME, null)
        this.pojoProjectRootDir = env.getOrDefault(EnvVariables.POJO_DIR, null)
        this.springbootAot = env.getOrDefault(EnvVariables.SPRINGBOOT_AOT, "false").toBooleanStrictOrNull() ?: false
    }
}

fun WriterOptions.getFolder(table: TableMetadata): GenerationPaths {
    val root = this.pojoProjectRootDir
    val pojoSrc = if (root != null) {
        Path(root, "src", "main", "kotlin")
    } else {
        findProjectSourceDir(File(table.sourceFile).parentFile.absolutePath)
    }
    createFolderIfNotExisted(pojoSrc)
    val tableDir = findProjectSourceDir(File(table.sourceFile).parentFile.absolutePath)

    val resource = findProjectResourceDir(File(table.sourceFile).parentFile.absolutePath)

    createFolderIfNotExisted(resource)

    val springResourceDir = Path(resource.absolutePathString(), "META-INF", "spring")

    val nativeResource = Path(resource.absolutePathString(), "META-INF", "native-image")

    return GenerationPaths(
        tableSourceDir = tableDir,
        pojoSourceDir =  pojoSrc,
        tableResourceDir = resource,
        springResourceDir = springResourceDir,
        nativeImageResourceDir = nativeResource
    )
}


private val ANY_WILDCARD = WildcardTypeName.producerOf(Any::class.asTypeName().copy(nullable = true))

fun ClassName.parameterizedWildcard(): ParameterizedTypeName {
    return this.parameterizedBy(ANY_WILDCARD)
}

private val srcPath = "/src/main/kotlin/".replace("/", File.separator)
private val resourcesPath = "/src/main/resources/".replace("/", File.separator)

fun findProjectRootDir(sourceFile: String): Path {
    val index = sourceFile.indexOf(srcPath)
    return if (index > 0) {
        val folder = sourceFile.substring(0, index).trimEnd(File.separatorChar)
        Path(folder)
    } else {
        throw ExposedGenerationException("Unable to get project root folder from file '${sourceFile}'")
    }
}

fun findProjectResourceDir(sourceFile: String): Path {
    val index = sourceFile.indexOf(srcPath)
    return if (index > 0) {
        val folder = sourceFile.substring(0, index)
        Path("${folder}${resourcesPath}".trimEnd(File.separatorChar))
    } else {
        Path(Path(sourceFile).parent.absolutePathString(), "resources")
    }
}

fun findProjectSourceDir(sourceFile: String): Path {
    val index = sourceFile.indexOf(srcPath)
    return if (index > 0) {
        val folder = sourceFile.substring(0, index)
        Path("${folder}${srcPath}".trimEnd(File.separatorChar))
    } else {
        Path(sourceFile).parent
    }
}

val suppressUncheckedCastAnnotation = AnnotationSpec.builder(Suppress::class)
    .addMember("%S", "UNCHECKED_CAST")
    .build()

fun suppressAnnotation(vararg args: String): AnnotationSpec {
    return AnnotationSpec.builder(Suppress::class)
        .apply {
            args.forEach {
                this.addMember("%S", it)
            }
        }
        .build()
}

fun FileSpec.Builder.suppressWarningTypes(vararg types: String): FileSpec.Builder {
    if (types.isNotEmpty()) {

        val format = "%S,".repeat(types.count()).trimEnd(',')
        return addAnnotation(
            AnnotationSpec.builder(ClassName("", "Suppress"))
                .addMember(format, *types)
                .build()
        )
    }
    return this
}

fun FileSpec.Builder.suppressRedundantVisibilityModifierWarning(): FileSpec.Builder {
    return this.suppressWarningTypes("RedundantVisibilityModifier")
}

fun convertToSpringConfig(values:  Map<String, Set<String>>): String {
    return StringBuilder().apply {
        values.forEach {
            kv->
            this.appendLine("${kv.key}=\\")
            this.appendLine(kv.value.joinToString(",\\\n"))
            this.appendLine()
        }
    }.toString()
}

fun parseSpringConfig(config: String): MutableMap<String, MutableSet<String>> {
    val result = mutableMapOf<String, MutableSet<String>>()
    val builder = StringBuilder()
    val completeLines = mutableListOf<String>()

    // 处理续行并构建完整行
    for (line in config.lineSequence()) {
        val trimmedLine = line.trim()
        if (trimmedLine.isEmpty()) continue  // 跳过空行

        if (trimmedLine.endsWith("\\")) {
            // 续行：移除反斜杠并添加到构建器
            builder.append(trimmedLine.substring(0, trimmedLine.length - 1).trim())
        } else {
            // 完整行：添加到构建器并完成
            builder.append(trimmedLine)
            completeLines.add(builder.toString())
            builder.clear()
        }
    }

    // 处理最后一行（如果以续行符结束）
    if (builder.isNotEmpty()) {
        completeLines.add(builder.toString())
    }

    // 解析每行配置
    for (line in completeLines) {
        val parts = line.split('=', limit = 2)
        if (parts.size == 2) {
            val key = parts[0].trim()
            val values = parts[1].split(',')
                .map { it.trim() }
                .filter { it.isNotEmpty() }
                .toSet()

            result.getOrPut(key) { mutableSetOf() }.addAll(values)
        }
    }

    return result
}