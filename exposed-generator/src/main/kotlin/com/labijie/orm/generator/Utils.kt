package com.labijie.orm.generator

import com.google.devtools.ksp.closestClassDeclaration
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.*
import com.labijie.orm.generator.DefaultValues.isConverterMethod
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.toClassName
import org.jetbrains.exposed.dao.id.EntityID
import org.jetbrains.exposed.sql.Column
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.net.URL
import java.nio.file.Files
import java.nio.file.Path
import java.util.Enumeration
import java.util.Properties
import kotlin.io.path.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.isDirectory
import kotlin.reflect.KClass

fun KSPLogger.println(message: String, symbol: KSNode? = null) {
    this.info("[expose gen] $message", symbol)
}

private fun <T : Any> loadResources(
    name: String, classLoader: ClassLoader?,
    filter: ((InputStream) -> T?)? = null
): T? {
    val systemResources: Enumeration<URL> =
        (classLoader ?: ClassLoader.getSystemClassLoader()).getResources(name)
    while (systemResources.hasMoreElements()) {
        systemResources.nextElement().openStream().use { stream ->
            val content: T? = filter?.invoke(stream)
            return content
        }
    }
    return null
}

private fun getGitProperties(
    packageClass: Class<*>,
    gitPropertiesFile: String = "git-info/git.properties",
): Properties? {
    if (gitPropertiesFile.isBlank()) {
        throw IllegalArgumentException("Git properties file can not be blank.")
    }
    return try {
        loadResources(gitPropertiesFile, packageClass.classLoader) {
            Properties().apply {
                this.load(it)
            }
        }

    } catch (e: IOException) {
        return null
    }
}


private val DEFAULT_CLASS_COMMENTS = "This code generated by an open-source project: Infra-Orm \nProject Site: https://github.com/hongque-pro/infra-orm.\n"

fun TypeSpec.Builder.addComments(classComment: String, context:GenerationContext): TypeSpec.Builder {
    val gitProperties = getGitProperties(VisitContext::class.java)
    val comment = CodeBlock.builder()
        .add(classComment)
        .add("\n")
        .add("\n")
        .add(DEFAULT_CLASS_COMMENTS)
        .add("Generator Version: ${gitProperties?.get("git.build.version") ?: "unknown"}\n")
        .add("\n")
        .add("\n")
        .add("Don't modify these codes !!")
        .add("\n")
        .add("\n")
        .add("Origin Exposed Table:")
        .add("\n")
        .add("@see ${context.tableClass.canonicalName}")
        .build()

    return this.addKdoc(comment)

}

private fun KSType.isExposedColumn(): Boolean {
    val isColumnType = this.declaration.qualifiedName?.asString() == Column::class.qualifiedName
    return isColumnType && this.declaration.typeParameters.size == 1
}


fun KSAnnotation.getProperties(): Map<String, Any?> {
    val defaultArgs = this.defaultArguments
    val defaultParams = mutableMapOf<Int, String>()
    defaultArgs.forEachIndexed { index, item ->
        val name = item.name?.getShortName()
        if (!name.isNullOrBlank()) {
            defaultParams[index] = name
        }
    }

    val args = this.arguments
    val parameterValues = mutableMapOf<String, Any?>()
    args.forEachIndexed { index, item ->
        val name = item.name?.getShortName() ?: defaultParams[index]
        if (!name.isNullOrBlank()) {
            parameterValues[name] = item.value
        }
    }
    return parameterValues
}

private fun KSType.getIDTypeFromEntityID(): KSType? {
    if (this.arguments.size != 1) {
        return null
    }
    if (this.declaration.qualifiedName?.asString() != EntityID::class.qualifiedName) {
        return null
    }
    return this.arguments.first().type?.resolve()
}



fun KSPropertyDeclaration.getColumnType(): ColumnType? {
    val argCount = this.type.element?.typeArguments?.count()

    if ((argCount == 1 || argCount == null)) {
        val propertyType = this.type.resolve()

        val columnType = propertyType.arguments.firstOrNull()?.type?.resolve()
        if (columnType != null) {
            val idType = columnType.getIDTypeFromEntityID()
            if (idType != null) {
                return ColumnType(columnType, idType, idType.isMarkedNullable)
            }
            return ColumnType(columnType, columnType, columnType.isMarkedNullable)
        }
    }
    //尽量避免解析
    return null
}

fun KSType.isEnum(): Boolean {
    val classDeclaration = this.declaration as? KSClassDeclaration
    return classDeclaration != null && classDeclaration.classKind == ClassKind.ENUM_CLASS
}

fun <T> KSType.isJavaType(javaClass: Class<T>): Boolean {
    val classDeclaration = this.declaration.qualifiedName?.asString()
    val className = "${javaClass.packageName}.${javaClass.simpleName}"
    return className == classDeclaration
}

fun KSType.isKotlinType(kclass: KClass<*>): Boolean {
    val kType = kclass.asTypeName()
    val cls = this.declaration.closestClassDeclaration()?.asStarProjectedType()?.toClassName()
    if(cls == null) {
        return false
    }
    return kType.compareTo(cls) == 0
}

fun generateParsedValueCodeBlock(valueVarName: String, parseMethod: MemberName?): CodeBlock {
    return CodeBlock.builder()
    .apply {
        parseMethod?.let {
            if (parseMethod.isConverterMethod()) {
                addStatement("%T.%N(${valueVarName})", parseMethod.enclosingClassName!!, parseMethod)
            } else {
                addStatement("${valueVarName}.%N()", parseMethod.simpleName)
            }
        } ?: addStatement(valueVarName)
    }
    .build()
}

fun generateToStringCodeBlock(valueVarName: String, toStringMethod: MemberName?): CodeBlock {
    return CodeBlock.builder()
        .apply {
            toStringMethod?.let {
                if (toStringMethod.isConverterMethod()) {
                    addStatement("%T.%N(${valueVarName})", toStringMethod.enclosingClassName!!, toStringMethod.simpleName)
                } else {
                    addStatement("${valueVarName}.%N()", toStringMethod.simpleName)
                }
            } ?: addStatement(valueVarName)
        }
        .build()
}

fun KSType.isJavaType(qualifiedClassName: String): Boolean {
    val classDeclaration = this.declaration.qualifiedName?.asString()
    return qualifiedClassName == classDeclaration
}


inline fun <reified T> KSType.isJavaType(): Boolean {
    val classDeclaration = this.declaration.qualifiedName?.asString()
    val kotlinClass = T::class.qualifiedName
    return kotlinClass.equals(classDeclaration)
}


private fun createFolderIfNotExisted(path: Path) {
    if (!Files.exists(path) || !path.isDirectory()) {
        path.createDirectories()
    }
}

fun buildWriterOptions(env: Map<String, String>): WriterOptions {
    val dir = env.getOrDefault(EnvVariables.PROJECT_DIR, null)
    if (dir != null && !Path(dir).isAbsolute) {
        throw ExposedGenerationException("`${EnvVariables.PROJECT_DIR}` must be an absolute path")
    }

    return WriterOptions().apply {
        this.packageName = env.getOrDefault(EnvVariables.PACKAGE_NAME, null)
        this.projectDir = env.getOrDefault(EnvVariables.PROJECT_DIR, null)
    }
}

fun WriterOptions.getSourceFolder(table: TableMetadata): Path {
    val root = this.projectDir
    if(root != null) {
        val path = Path(root, "src", "main", "kotlin")
        createFolderIfNotExisted(path)
        return path
    }
    return findProjectSourceDir(File(table.sourceFile).parentFile.absolutePath)
}


private val ANY_WILDCARD = WildcardTypeName.producerOf(Any::class.asTypeName().copy(nullable = true))

fun ClassName.parameterizedWildcard(): ParameterizedTypeName {
    return this.parameterizedBy(ANY_WILDCARD)
}

private val srcPath = "/src/main/kotlin/".replace("/", File.separator)
private val folders = mutableMapOf<String, Path>()

fun findProjectSourceDir(sourceFile: String): Path {
    val existed = folders[sourceFile]
    if(existed != null){
        return existed
    }
    val index = sourceFile.indexOf(srcPath)
    if(index > 0) {
        val folder = sourceFile.substring(0, index)
        folders[sourceFile] = Path("${folder}${srcPath}".trimEnd(File.separatorChar))
    }else {
        folders[sourceFile] = Path(File(sourceFile).parentFile.absolutePath)
    }
    return folders[sourceFile] ?: throw ExposedGenerationException("Unable to get project folder from file '${sourceFile}'")
}

val suppressUncheckedCastAnnotation = AnnotationSpec.builder(Suppress::class)
    .addMember("%S", "UNCHECKED_CAST")
    .build()

fun suppressAnnotation(vararg args: String): AnnotationSpec {
    return AnnotationSpec.builder(Suppress::class)
        .apply {
            args.forEach {
                this.addMember("%S", it)
            }
        }
    .build()
}

fun FileSpec.Builder.suppressWarningTypes(vararg types: String): FileSpec.Builder {
    if (types.isNotEmpty()) {

        val format = "%S,".repeat(types.count()).trimEnd(',')
        return addAnnotation(
            AnnotationSpec.builder(ClassName("", "Suppress"))
                .addMember(format, *types)
                .build()
        )
    }
    return this
}

fun FileSpec.Builder.suppressRedundantVisibilityModifierWarning(): FileSpec.Builder {
    return this.suppressWarningTypes("RedundantVisibilityModifier")
}