@file:Suppress("RedundantVisibilityModifier")

package com.labijie.orm.dummy.pojo.dsl

import com.labijie.infra.orm.OffsetList
import com.labijie.orm.dummy.TestEnum
import com.labijie.orm.dummy.TestSimpleTable
import com.labijie.orm.dummy.TestSimpleTable.`enum`
import com.labijie.orm.dummy.TestSimpleTable.binary
import com.labijie.orm.dummy.TestSimpleTable.binaryNullable
import com.labijie.orm.dummy.TestSimpleTable.bool
import com.labijie.orm.dummy.TestSimpleTable.booleanNullable
import com.labijie.orm.dummy.TestSimpleTable.byte
import com.labijie.orm.dummy.TestSimpleTable.byteNullable
import com.labijie.orm.dummy.TestSimpleTable.char
import com.labijie.orm.dummy.TestSimpleTable.charNullable
import com.labijie.orm.dummy.TestSimpleTable.dateTime
import com.labijie.orm.dummy.TestSimpleTable.dateTimeNullable
import com.labijie.orm.dummy.TestSimpleTable.duration
import com.labijie.orm.dummy.TestSimpleTable.durationNullable
import com.labijie.orm.dummy.TestSimpleTable.enumNullable
import com.labijie.orm.dummy.TestSimpleTable.id
import com.labijie.orm.dummy.TestSimpleTable.memo
import com.labijie.orm.dummy.TestSimpleTable.memoNullable
import com.labijie.orm.dummy.TestSimpleTable.name
import com.labijie.orm.dummy.TestSimpleTable.nameNullable
import com.labijie.orm.dummy.TestSimpleTable.short
import com.labijie.orm.dummy.TestSimpleTable.shortNullable
import com.labijie.orm.dummy.TestSimpleTable.text
import com.labijie.orm.dummy.TestSimpleTable.textNullable
import com.labijie.orm.dummy.TestSimpleTable.uid
import com.labijie.orm.dummy.TestSimpleTable.uidNullable
import com.labijie.orm.dummy.pojo.TestSimple
import java.lang.IllegalArgumentException
import java.time.Duration
import java.time.LocalDateTime
import java.util.UUID
import kotlin.Array
import kotlin.Boolean
import kotlin.Byte
import kotlin.ByteArray
import kotlin.Char
import kotlin.Comparable
import kotlin.Int
import kotlin.Long
import kotlin.Number
import kotlin.Short
import kotlin.String
import kotlin.Unit
import kotlin.collections.Collection
import kotlin.collections.Iterable
import kotlin.collections.List
import kotlin.collections.isNotEmpty
import kotlin.collections.last
import kotlin.collections.toList
import kotlin.reflect.KClass
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Op
import org.jetbrains.exposed.sql.Query
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.SqlExpressionBuilder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.andWhere
import org.jetbrains.exposed.sql.batchInsert
import org.jetbrains.exposed.sql.batchUpsert
import org.jetbrains.exposed.sql.deleteWhere
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.insertIgnore
import org.jetbrains.exposed.sql.replace
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.statements.InsertStatement
import org.jetbrains.exposed.sql.statements.ReplaceStatement
import org.jetbrains.exposed.sql.statements.UpdateBuilder
import org.jetbrains.exposed.sql.statements.UpdateStatement
import org.jetbrains.exposed.sql.statements.UpsertBuilder
import org.jetbrains.exposed.sql.statements.UpsertStatement
import org.jetbrains.exposed.sql.update
import org.jetbrains.exposed.sql.upsert

/**
 * DSL support for TestSimpleTable
 *
 * This code generated by an open-source project: Infra-Orm 
 * Project Site: https://github.com/hongque-pro/infra-orm.
 * Generator Version: unknown
 *
 *
 * Don't modify these codes !!
 *
 * Origin Exposed Table:
 * @see com.labijie.orm.dummy.TestSimpleTable
 */
@kotlin.Suppress(
  "unused",
  "DuplicatedCode",
  "MemberVisibilityCanBePrivate",
  "RemoveRedundantQualifierName",
)
public object TestSimpleDSL {
  public val TestSimpleTable.allColumns: Array<Column<*>> by lazy {
    arrayOf(
    name,
    memo,
    char,
    text,
    enum,
    binary,
    uid,
    short,
    bool,
    byte,
    dateTime,
    duration,
    nameNullable,
    memoNullable,
    charNullable,
    textNullable,
    enumNullable,
    binaryNullable,
    uidNullable,
    shortNullable,
    booleanNullable,
    byteNullable,
    dateTimeNullable,
    durationNullable,
    id,
    )
  }

  public fun parseRow(raw: ResultRow): TestSimple {
    val plain = TestSimple()
    plain.name = raw[name]
    plain.memo = raw[memo]
    plain.char = raw[char]
    plain.text = raw[text]
    plain.enum = raw[enum]
    plain.binary = raw[binary]
    plain.uid = raw[uid]
    plain.short = raw[short]
    plain.bool = raw[bool]
    plain.byte = raw[byte]
    plain.dateTime = raw[dateTime]
    plain.duration = raw[duration]
    plain.nameNullable = raw[nameNullable]
    plain.memoNullable = raw[memoNullable]
    plain.charNullable = raw[charNullable]
    plain.textNullable = raw[textNullable]
    plain.enumNullable = raw[enumNullable]
    plain.binaryNullable = raw[binaryNullable]
    plain.uidNullable = raw[uidNullable]
    plain.shortNullable = raw[shortNullable]
    plain.booleanNullable = raw[booleanNullable]
    plain.byteNullable = raw[byteNullable]
    plain.dateTimeNullable = raw[dateTimeNullable]
    plain.durationNullable = raw[durationNullable]
    plain.id = raw[id]
    return plain
  }

  public fun parseRowSelective(row: ResultRow): TestSimple {
    val plain = TestSimple()
    if(row.hasValue(name)) {
      plain.name = row[name]
    }
    if(row.hasValue(memo)) {
      plain.memo = row[memo]
    }
    if(row.hasValue(char)) {
      plain.char = row[char]
    }
    if(row.hasValue(text)) {
      plain.text = row[text]
    }
    if(row.hasValue(enum)) {
      plain.enum = row[enum]
    }
    if(row.hasValue(binary)) {
      plain.binary = row[binary]
    }
    if(row.hasValue(uid)) {
      plain.uid = row[uid]
    }
    if(row.hasValue(short)) {
      plain.short = row[short]
    }
    if(row.hasValue(bool)) {
      plain.bool = row[bool]
    }
    if(row.hasValue(byte)) {
      plain.byte = row[byte]
    }
    if(row.hasValue(dateTime)) {
      plain.dateTime = row[dateTime]
    }
    if(row.hasValue(duration)) {
      plain.duration = row[duration]
    }
    if(row.hasValue(nameNullable)) {
      plain.nameNullable = row[nameNullable]
    }
    if(row.hasValue(memoNullable)) {
      plain.memoNullable = row[memoNullable]
    }
    if(row.hasValue(charNullable)) {
      plain.charNullable = row[charNullable]
    }
    if(row.hasValue(textNullable)) {
      plain.textNullable = row[textNullable]
    }
    if(row.hasValue(enumNullable)) {
      plain.enumNullable = row[enumNullable]
    }
    if(row.hasValue(binaryNullable)) {
      plain.binaryNullable = row[binaryNullable]
    }
    if(row.hasValue(uidNullable)) {
      plain.uidNullable = row[uidNullable]
    }
    if(row.hasValue(shortNullable)) {
      plain.shortNullable = row[shortNullable]
    }
    if(row.hasValue(booleanNullable)) {
      plain.booleanNullable = row[booleanNullable]
    }
    if(row.hasValue(byteNullable)) {
      plain.byteNullable = row[byteNullable]
    }
    if(row.hasValue(dateTimeNullable)) {
      plain.dateTimeNullable = row[dateTimeNullable]
    }
    if(row.hasValue(durationNullable)) {
      plain.durationNullable = row[durationNullable]
    }
    if(row.hasValue(id)) {
      plain.id = row[id]
    }
    return plain
  }

  public fun <T> TestSimpleTable.getColumnType(column: Column<T>): KClass<*> = when(column) {
    name->String::class
    memo->String::class
    char->Char::class
    text->String::class
    enum->TestEnum::class
    binary->ByteArray::class
    uid->UUID::class
    short->Short::class
    bool->Boolean::class
    byte->Byte::class
    dateTime->LocalDateTime::class
    duration->Duration::class
    nameNullable->String::class
    memoNullable->String::class
    charNullable->Char::class
    textNullable->String::class
    enumNullable->TestEnum::class
    binaryNullable->ByteArray::class
    uidNullable->UUID::class
    shortNullable->Short::class
    booleanNullable->Boolean::class
    byteNullable->Byte::class
    dateTimeNullable->LocalDateTime::class
    durationNullable->Duration::class
    id->String::class
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'TestSimple'""")
  }

  private fun <T> TestSimple.getColumnValueString(column: Column<T>): String = when(column) {
    TestSimpleTable.name->this.name
    TestSimpleTable.memo->this.memo.orEmpty()
    TestSimpleTable.char -> this.char.toString()

    TestSimpleTable.text->this.text
    TestSimpleTable.binary -> com.labijie.infra.orm.ExposedConverter.byteArrayToString(this.binary)

    TestSimpleTable.uid -> this.uid.toString()

    TestSimpleTable.short -> this.short.toString()

    TestSimpleTable.bool -> this.bool.toString()

    TestSimpleTable.byte -> this.byte.toString()

    TestSimpleTable.dateTime -> this.dateTime.toString()

    TestSimpleTable.duration -> com.labijie.infra.orm.ExposedConverter.durationToString(this.duration)

    TestSimpleTable.nameNullable->this.nameNullable.orEmpty()
    TestSimpleTable.memoNullable->this.memoNullable.orEmpty()
    TestSimpleTable.charNullable -> (this.charNullable?.toString()).orEmpty()

    TestSimpleTable.textNullable->this.textNullable.orEmpty()
    TestSimpleTable.binaryNullable -> com.labijie.infra.orm.ExposedConverter.byteArrayToString(this.binaryNullable)

    TestSimpleTable.uidNullable -> (this.uidNullable?.toString()).orEmpty()

    TestSimpleTable.shortNullable -> (this.shortNullable?.toString()).orEmpty()

    TestSimpleTable.booleanNullable -> (this.booleanNullable?.toString()).orEmpty()

    TestSimpleTable.byteNullable -> (this.byteNullable?.toString()).orEmpty()

    TestSimpleTable.dateTimeNullable -> (this.dateTimeNullable?.toString()).orEmpty()

    TestSimpleTable.durationNullable -> com.labijie.infra.orm.ExposedConverter.durationToString(this.durationNullable)

    TestSimpleTable.id->this.id
    else->throw IllegalArgumentException("""Can't converter value of TestSimple::${column.name} to string.""")
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  private fun <T> parseColumnValue(valueString: String, column: Column<T>): T {
    val value = when(column) {
      TestSimpleTable.name -> valueString
      TestSimpleTable.memo -> valueString
      TestSimpleTable.char ->valueString.first()
      TestSimpleTable.text -> valueString
      TestSimpleTable.binary ->com.labijie.infra.orm.ExposedConverter.stringToByteArray(valueString)
      TestSimpleTable.uid ->com.labijie.infra.orm.ExposedConverter.stringToUUID(valueString)
      TestSimpleTable.short ->valueString.toShort()
      TestSimpleTable.bool ->valueString.toBoolean()
      TestSimpleTable.byte ->valueString.toByteOrNull()
      TestSimpleTable.dateTime ->com.labijie.infra.orm.ExposedConverter.stringToLocalDateTime(valueString)
      TestSimpleTable.duration ->com.labijie.infra.orm.ExposedConverter.stringToDuration(valueString)
      TestSimpleTable.nameNullable -> valueString
      TestSimpleTable.memoNullable -> valueString
      TestSimpleTable.charNullable ->valueString.firstOrNull()
      TestSimpleTable.textNullable -> valueString
      TestSimpleTable.binaryNullable ->com.labijie.infra.orm.ExposedConverter.stringToByteArrayOrNull(valueString)
      TestSimpleTable.uidNullable ->com.labijie.infra.orm.ExposedConverter.stringToUUIDOrNull(valueString)
      TestSimpleTable.shortNullable ->valueString.toShortOrNull()
      TestSimpleTable.booleanNullable ->valueString.toBooleanStrictOrNull()
      TestSimpleTable.byteNullable ->valueString.toByte()
      TestSimpleTable.dateTimeNullable ->com.labijie.infra.orm.ExposedConverter.stringToLocalDateTimeOrNull(valueString)
      TestSimpleTable.durationNullable ->com.labijie.infra.orm.ExposedConverter.stringToDuration(valueString)
      TestSimpleTable.id -> valueString
      else->throw IllegalArgumentException("""Can't converter value of TestSimple::${column.name} to string.""")
    }
    return value as T
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  public fun <T> TestSimple.getColumnValue(column: Column<T>): T = when(column) {
    TestSimpleTable.name->this.name as T
    TestSimpleTable.memo->this.memo as T
    TestSimpleTable.char->this.char as T
    TestSimpleTable.text->this.text as T
    TestSimpleTable.enum->this.enum as T
    TestSimpleTable.binary->this.binary as T
    TestSimpleTable.uid->this.uid as T
    TestSimpleTable.short->this.short as T
    TestSimpleTable.bool->this.bool as T
    TestSimpleTable.byte->this.byte as T
    TestSimpleTable.dateTime->this.dateTime as T
    TestSimpleTable.duration->this.duration as T
    TestSimpleTable.nameNullable->this.nameNullable as T
    TestSimpleTable.memoNullable->this.memoNullable as T
    TestSimpleTable.charNullable->this.charNullable as T
    TestSimpleTable.textNullable->this.textNullable as T
    TestSimpleTable.enumNullable->this.enumNullable as T
    TestSimpleTable.binaryNullable->this.binaryNullable as T
    TestSimpleTable.uidNullable->this.uidNullable as T
    TestSimpleTable.shortNullable->this.shortNullable as T
    TestSimpleTable.booleanNullable->this.booleanNullable as T
    TestSimpleTable.byteNullable->this.byteNullable as T
    TestSimpleTable.dateTimeNullable->this.dateTimeNullable as T
    TestSimpleTable.durationNullable->this.durationNullable as T
    TestSimpleTable.id->this.id as T
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'TestSimple'""")
  }

  public fun assign(
    builder: UpdateBuilder<*>,
    raw: TestSimple,
    selective: Array<out Column<*>>? = null,
    vararg ignore: Column<*>,
  ) {
    val list = if(selective.isNullOrEmpty()) null else selective
    if((list == null || list.contains(name)) && !ignore.contains(name))
      builder[name] = raw.name
    if((list == null || list.contains(memo)) && !ignore.contains(memo))
      builder[memo] = raw.memo
    if((list == null || list.contains(char)) && !ignore.contains(char))
      builder[char] = raw.char
    if((list == null || list.contains(text)) && !ignore.contains(text))
      builder[text] = raw.text
    if((list == null || list.contains(enum)) && !ignore.contains(enum))
      builder[enum] = raw.enum
    if((list == null || list.contains(binary)) && !ignore.contains(binary))
      builder[binary] = raw.binary
    if((list == null || list.contains(uid)) && !ignore.contains(uid))
      builder[uid] = raw.uid
    if((list == null || list.contains(short)) && !ignore.contains(short))
      builder[short] = raw.short
    if((list == null || list.contains(bool)) && !ignore.contains(bool))
      builder[bool] = raw.bool
    if((list == null || list.contains(byte)) && !ignore.contains(byte))
      builder[byte] = raw.byte
    if((list == null || list.contains(dateTime)) && !ignore.contains(dateTime))
      builder[dateTime] = raw.dateTime
    if((list == null || list.contains(duration)) && !ignore.contains(duration))
      builder[duration] = raw.duration
    if((list == null || list.contains(nameNullable)) && !ignore.contains(nameNullable))
      builder[nameNullable] = raw.nameNullable
    if((list == null || list.contains(memoNullable)) && !ignore.contains(memoNullable))
      builder[memoNullable] = raw.memoNullable
    if((list == null || list.contains(charNullable)) && !ignore.contains(charNullable))
      builder[charNullable] = raw.charNullable
    if((list == null || list.contains(textNullable)) && !ignore.contains(textNullable))
      builder[textNullable] = raw.textNullable
    if((list == null || list.contains(enumNullable)) && !ignore.contains(enumNullable))
      builder[enumNullable] = raw.enumNullable
    if((list == null || list.contains(binaryNullable)) && !ignore.contains(binaryNullable))
      builder[binaryNullable] = raw.binaryNullable
    if((list == null || list.contains(uidNullable)) && !ignore.contains(uidNullable))
      builder[uidNullable] = raw.uidNullable
    if((list == null || list.contains(shortNullable)) && !ignore.contains(shortNullable))
      builder[shortNullable] = raw.shortNullable
    if((list == null || list.contains(booleanNullable)) && !ignore.contains(booleanNullable))
      builder[booleanNullable] = raw.booleanNullable
    if((list == null || list.contains(byteNullable)) && !ignore.contains(byteNullable))
      builder[byteNullable] = raw.byteNullable
    if((list == null || list.contains(dateTimeNullable)) && !ignore.contains(dateTimeNullable))
      builder[dateTimeNullable] = raw.dateTimeNullable
    if((list == null || list.contains(durationNullable)) && !ignore.contains(durationNullable))
      builder[durationNullable] = raw.durationNullable
    if((list == null || list.contains(id)) && !ignore.contains(id))
      builder[id] = raw.id
  }

  public fun ResultRow.toTestSimple(vararg selective: Column<*>): TestSimple {
    if(selective.isNotEmpty()) {
      return parseRowSelective(this)
    }
    return parseRow(this)
  }

  public fun Iterable<ResultRow>.toTestSimpleList(vararg selective: Column<*>): List<TestSimple> = this.map {
    it.toTestSimple(*selective)
  }

  public fun TestSimpleTable.selectSlice(vararg selective: Column<*>): Query {
    val query = if(selective.isNotEmpty()) {
      select(selective.toList())
    }
    else {
      selectAll()
    }
    return query
  }

  public fun UpdateBuilder<*>.setValue(raw: TestSimple, vararg ignore: Column<*>): Unit = assign(this, raw, ignore = ignore)

  public fun UpdateBuilder<*>.setValueSelective(raw: TestSimple, vararg selective: Column<*>): Unit = assign(this, raw, selective = selective)

  public fun TestSimpleTable.insert(raw: TestSimple): InsertStatement<Number> = insert {
    assign(it, raw)
  }

  public fun TestSimpleTable.insertIgnore(raw: TestSimple): InsertStatement<Long> = insertIgnore {
    assign(it, raw)
  }

  public fun TestSimpleTable.upsert(
    raw: TestSimple,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): UpsertStatement<Long> = upsert(where = where, onUpdate = onUpdate, onUpdateExclude = onUpdateExclude) {
    assign(it, raw)
  }

  public fun TestSimpleTable.batchInsert(
    list: Iterable<TestSimple>,
    ignoreErrors: Boolean = false,
    shouldReturnGeneratedValues: Boolean = false,
  ): List<ResultRow> {
    val rows = batchInsert(list, ignoreErrors, shouldReturnGeneratedValues) {
      entry -> assign(this, entry)
    }
    return rows
  }

  public fun TestSimpleTable.batchUpsert(
    list: Iterable<TestSimple>,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    shouldReturnGeneratedValues: Boolean = false,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): List<ResultRow> {
    val rows =  batchUpsert(data = list, keys = arrayOf(id), onUpdate = onUpdate, onUpdateExclude = onUpdateExclude, where = where, shouldReturnGeneratedValues = shouldReturnGeneratedValues) {
      data: TestSimple-> assign(this, data)
    }
    return rows
  }

  public fun TestSimpleTable.update(
    raw: TestSimple,
    selective: Array<out Column<*>>? = null,
    ignore: Array<out Column<*>>? = null,
    limit: Int? = null,
    `where`: SqlExpressionBuilder.() -> Op<Boolean>,
  ): Int = update(`where`, limit) {
    val ignoreColumns = ignore ?: arrayOf()
    assign(it, raw, selective = selective, *ignoreColumns)
  }

  public fun TestSimpleTable.updateByPrimaryKey(raw: TestSimple, vararg selective: Column<*>): Int = update(raw, selective = selective, ignore = arrayOf(id)) {
    TestSimpleTable.id.eq(raw.id)
  }

  public fun TestSimpleTable.updateByPrimaryKey(id: String, builder: TestSimpleTable.(UpdateStatement) -> Unit): Int = update({ TestSimpleTable.id.eq(id) }, body = builder)

  public fun TestSimpleTable.deleteByPrimaryKey(id: String): Int = deleteWhere {
    TestSimpleTable.id.eq(id)
  }

  public fun TestSimpleTable.selectByPrimaryKey(id: String, vararg selective: Column<*>): TestSimple? {
    val query = selectSlice(*selective).andWhere {
      TestSimpleTable.id.eq(id)
    }
    return query.firstOrNull()?.toTestSimple(*selective)
  }

  public fun TestSimpleTable.selectByPrimaryKeys(ids: Iterable<String>, vararg selective: Column<*>): List<TestSimple> {
    val query = selectSlice(*selective).andWhere {
      TestSimpleTable.id inList ids
    }
    return query.toTestSimpleList(*selective)
  }

  public fun TestSimpleTable.selectMany(vararg selective: Column<*>, `where`: Query.() -> Query?): List<TestSimple> {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.toTestSimpleList(*selective)
  }

  public fun TestSimpleTable.selectOne(vararg selective: Column<*>, `where`: Query.() -> Query?): TestSimple? {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.firstOrNull()?.toTestSimple(*selective)
  }

  public fun TestSimpleTable.selectForwardByPrimaryKey(
    forwardToken: String? = null,
    order: SortOrder = SortOrder.DESC,
    pageSize: Int = 50,
    selective: Collection<Column<*>> = listOf(),
    `where`: (Query.() -> Query?)? = null,
  ): OffsetList<TestSimple> {
    if(pageSize < 1) {
      return OffsetList.empty()
    }
    val offsetKey = forwardToken?.let { OffsetList.decodeToken(it).firstOrNull()?.ifBlank { null } }
    val query = selectSlice(*selective.toTypedArray())
    offsetKey?.let {
      val keyValue = parseColumnValue(it, id)
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { id less keyValue }
        else-> query.andWhere { id greater keyValue }
      }
    }
    `where`?.invoke(query)
    val sorted = query.orderBy(id, order)
    val list = sorted.limit(pageSize + 1).toTestSimpleList(*selective.toTypedArray()).toMutableList()
    val dataCount = list.size
    val token = if(dataCount > pageSize) {
      list.removeLast()
      val idString = list.last().getColumnValueString(id)
      OffsetList.encodeToken(idString)
    }
    else {
      null
    }
    return OffsetList(list, token)
  }

  public fun <T : Comparable<T>> TestSimpleTable.selectForward(
    sortColumn: Column<T>,
    forwardToken: String? = null,
    order: SortOrder = SortOrder.DESC,
    pageSize: Int = 50,
    selective: Collection<Column<*>> = listOf(),
    `where`: (Query.() -> Query?)? = null,
  ): OffsetList<TestSimple> {
    if(pageSize < 1) {
      return OffsetList.empty()
    }
    if(sortColumn == id) {
      return this.selectForwardByPrimaryKey(forwardToken, order, pageSize, selective, `where`)
    }
    val kp = forwardToken?.let { if(it.isNotBlank()) OffsetList.decodeToken(it) else null }
    val offsetKey = if(!kp.isNullOrEmpty()) parseColumnValue(kp.first(), sortColumn) else null
    val lastId = if(kp != null && kp.size > 1 && kp[1].isNotBlank()) parseColumnValue(kp[1], id) else null
    val query = selectSlice(*selective.toTypedArray())
    offsetKey?.let {
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { sortColumn lessEq it }
        else-> query.andWhere { sortColumn greaterEq it }
      }
    }
    lastId?.let {
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { id less it }
        else-> query.andWhere { id greater it }
      }
    }
    `where`?.invoke(query)
    val sorted = query.orderBy(Pair(sortColumn, order), Pair(id, order))
    val list = sorted.limit(pageSize + 1).toTestSimpleList(*selective.toTypedArray()).toMutableList()
    val dataCount = list.size
    val token = if(dataCount > pageSize) {
      list.removeLast()
      val idToEncode = list.last().getColumnValueString(id)
      val sortKey = list.last().getColumnValueString(sortColumn)
      OffsetList.encodeToken(arrayOf(sortKey, idToEncode))
    }
    else null
    return OffsetList(list, token)
  }

  public fun TestSimpleTable.replace(raw: TestSimple): ReplaceStatement<Long> = replace {
    assign(it, raw)
  }
}
