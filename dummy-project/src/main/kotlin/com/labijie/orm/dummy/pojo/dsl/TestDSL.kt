@file:Suppress("RedundantVisibilityModifier")

package com.labijie.orm.dummy.pojo.dsl

import com.labijie.infra.orm.OffsetList
import com.labijie.orm.dummy.TestEnum
import com.labijie.orm.dummy.TestTable
import com.labijie.orm.dummy.TestTable.array
import com.labijie.orm.dummy.TestTable.date
import com.labijie.orm.dummy.TestTable.dateTime
import com.labijie.orm.dummy.TestTable.datetime
import com.labijie.orm.dummy.TestTable.datetimeNullable
import com.labijie.orm.dummy.TestTable.decimal
import com.labijie.orm.dummy.TestTable.decimalNullable
import com.labijie.orm.dummy.TestTable.description
import com.labijie.orm.dummy.TestTable.duration
import com.labijie.orm.dummy.TestTable.id
import com.labijie.orm.dummy.TestTable.status
import com.labijie.orm.dummy.TestTable.status2
import com.labijie.orm.dummy.TestTable.time
import com.labijie.orm.dummy.TestTable.timestamp
import com.labijie.orm.dummy.TestTable.title
import com.labijie.orm.dummy.TestTable.uuid
import com.labijie.orm.dummy.TestTable.uuidNullable
import com.labijie.orm.dummy.otherpackage.NestedInterface
import com.labijie.orm.dummy.pojo.Test
import java.lang.IllegalArgumentException
import java.math.BigDecimal
import java.time.Duration
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.util.UUID
import kotlin.Array
import kotlin.Boolean
import kotlin.Comparable
import kotlin.Int
import kotlin.Long
import kotlin.Number
import kotlin.String
import kotlin.Unit
import kotlin.collections.Collection
import kotlin.collections.Iterable
import kotlin.collections.List
import kotlin.collections.isNotEmpty
import kotlin.collections.last
import kotlin.collections.toList
import kotlin.reflect.KClass
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Op
import org.jetbrains.exposed.sql.Query
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.SqlExpressionBuilder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.andWhere
import org.jetbrains.exposed.sql.batchInsert
import org.jetbrains.exposed.sql.batchUpsert
import org.jetbrains.exposed.sql.deleteWhere
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.insertIgnore
import org.jetbrains.exposed.sql.replace
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.statements.InsertStatement
import org.jetbrains.exposed.sql.statements.ReplaceStatement
import org.jetbrains.exposed.sql.statements.UpdateBuilder
import org.jetbrains.exposed.sql.statements.UpdateStatement
import org.jetbrains.exposed.sql.statements.UpsertBuilder
import org.jetbrains.exposed.sql.statements.UpsertStatement
import org.jetbrains.exposed.sql.update
import org.jetbrains.exposed.sql.upsert

/**
 * DSL support for TestTable
 *
 * This code generated by an open-source project: Infra-Orm 
 * Project Site: https://github.com/hongque-pro/infra-orm.
 * Generator Version: 2.1.0
 *
 *
 * Don't modify these codes !!
 *
 * Origin Exposed Table:
 * @see com.labijie.orm.dummy.TestTable
 */
@kotlin.Suppress(
  "unused",
  "DuplicatedCode",
  "MemberVisibilityCanBePrivate",
  "RemoveRedundantQualifierName",
)
public object TestDSL {
  public val TestTable.allColumns: Array<Column<*>> by lazy {
    arrayOf(
    title,
    status,
    description,
    status2,
    array,
    dateTime,
    duration,
    time,
    date,
    timestamp,
    decimal,
    decimalNullable,
    uuid,
    uuidNullable,
    datetime,
    datetimeNullable,
    id,
    )
  }

  public fun parseRow(raw: ResultRow): Test {
    val plain = Test()
    plain.title = raw[title]
    plain.status = raw[status]
    plain.description = raw[description]
    plain.status2 = raw[status2]
    plain.array = raw[array]
    plain.dateTime = raw[dateTime]
    plain.duration = raw[duration]
    plain.time = raw[time]
    plain.date = raw[date]
    plain.timestamp = raw[timestamp]
    plain.decimal = raw[decimal]
    plain.decimalNullable = raw[decimalNullable]
    plain.uuid = raw[uuid]
    plain.uuidNullable = raw[uuidNullable]
    plain.datetime = raw[datetime]
    plain.datetimeNullable = raw[datetimeNullable]
    plain.id = raw[id]
    return plain
  }

  public fun parseRowSelective(row: ResultRow): Test {
    val plain = Test()
    if(row.hasValue(title)) {
      plain.title = row[title]
    }
    if(row.hasValue(status)) {
      plain.status = row[status]
    }
    if(row.hasValue(description)) {
      plain.description = row[description]
    }
    if(row.hasValue(status2)) {
      plain.status2 = row[status2]
    }
    if(row.hasValue(array)) {
      plain.array = row[array]
    }
    if(row.hasValue(dateTime)) {
      plain.dateTime = row[dateTime]
    }
    if(row.hasValue(duration)) {
      plain.duration = row[duration]
    }
    if(row.hasValue(time)) {
      plain.time = row[time]
    }
    if(row.hasValue(date)) {
      plain.date = row[date]
    }
    if(row.hasValue(timestamp)) {
      plain.timestamp = row[timestamp]
    }
    if(row.hasValue(decimal)) {
      plain.decimal = row[decimal]
    }
    if(row.hasValue(decimalNullable)) {
      plain.decimalNullable = row[decimalNullable]
    }
    if(row.hasValue(uuid)) {
      plain.uuid = row[uuid]
    }
    if(row.hasValue(uuidNullable)) {
      plain.uuidNullable = row[uuidNullable]
    }
    if(row.hasValue(datetime)) {
      plain.datetime = row[datetime]
    }
    if(row.hasValue(datetimeNullable)) {
      plain.datetimeNullable = row[datetimeNullable]
    }
    if(row.hasValue(id)) {
      plain.id = row[id]
    }
    return plain
  }

  public fun <T> TestTable.getColumnType(column: Column<T>): KClass<*> = when(column) {
    title->String::class
    status->TestEnum::class
    description->String::class
    status2->NestedInterface.StatusEnum::class
    array->List::class
    dateTime->LocalDateTime::class
    duration->Duration::class
    time->LocalTime::class
    date->LocalDate::class
    timestamp->Instant::class
    decimal->BigDecimal::class
    decimalNullable->BigDecimal::class
    uuid->UUID::class
    uuidNullable->UUID::class
    datetime->LocalDateTime::class
    datetimeNullable->LocalDateTime::class
    id->Long::class
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'Test'""")
  }

  private fun <T> Test.getColumnValueString(column: Column<T>): String = when(column) {
    TestTable.title->this.title.orEmpty()
    TestTable.description->this.description
    TestTable.dateTime -> this.dateTime.toString()

    TestTable.duration -> com.labijie.infra.orm.ExposedConverter.durationToString(this.duration)

    TestTable.time -> this.time.toString()

    TestTable.date -> this.date.toString()

    TestTable.timestamp -> com.labijie.infra.orm.ExposedConverter.instantToString(this.timestamp)

    TestTable.decimal -> this.decimal.toString()

    TestTable.decimalNullable -> (this.decimalNullable?.toString()).orEmpty()

    TestTable.uuid -> this.uuid.toString()

    TestTable.uuidNullable -> (this.uuidNullable?.toString()).orEmpty()

    TestTable.datetime -> this.datetime.toString()

    TestTable.datetimeNullable -> (this.datetimeNullable?.toString()).orEmpty()

    TestTable.id -> this.id.toString()

    else->throw IllegalArgumentException("""Can't converter value of Test::${column.name} to string.""")
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  private fun <T> parseColumnValue(valueString: String, column: Column<T>): T {
    val value = when(column) {
      TestTable.title -> valueString
      TestTable.description -> valueString
      TestTable.dateTime ->com.labijie.infra.orm.ExposedConverter.stringToLocalDateTime(valueString)
      TestTable.duration ->com.labijie.infra.orm.ExposedConverter.stringToDuration(valueString)
      TestTable.time ->com.labijie.infra.orm.ExposedConverter.stringToLocalTime(valueString)
      TestTable.date ->com.labijie.infra.orm.ExposedConverter.stringToLocalDate(valueString)
      TestTable.timestamp ->com.labijie.infra.orm.ExposedConverter.stringToInstant(valueString)
      TestTable.decimal ->valueString.toDouble()
      TestTable.decimalNullable ->valueString.toDoubleOrNull()
      TestTable.uuid ->com.labijie.infra.orm.ExposedConverter.stringToUUID(valueString)
      TestTable.uuidNullable ->com.labijie.infra.orm.ExposedConverter.stringToUUIDOrNull(valueString)
      TestTable.datetime ->com.labijie.infra.orm.ExposedConverter.stringToLocalDateTime(valueString)
      TestTable.datetimeNullable ->com.labijie.infra.orm.ExposedConverter.stringToLocalDateTimeOrNull(valueString)
      TestTable.id ->valueString.toLong()
      else->throw IllegalArgumentException("""Can't converter value of Test::${column.name} to string.""")
    }
    return value as T
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  public fun <T> Test.getColumnValue(column: Column<T>): T = when(column) {
    TestTable.title->this.title as T
    TestTable.status->this.status as T
    TestTable.description->this.description as T
    TestTable.status2->this.status2 as T
    TestTable.array->this.array as T
    TestTable.dateTime->this.dateTime as T
    TestTable.duration->this.duration as T
    TestTable.time->this.time as T
    TestTable.date->this.date as T
    TestTable.timestamp->this.timestamp as T
    TestTable.decimal->this.decimal as T
    TestTable.decimalNullable->this.decimalNullable as T
    TestTable.uuid->this.uuid as T
    TestTable.uuidNullable->this.uuidNullable as T
    TestTable.datetime->this.datetime as T
    TestTable.datetimeNullable->this.datetimeNullable as T
    TestTable.id->this.id as T
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'Test'""")
  }

  public fun assign(
    builder: UpdateBuilder<*>,
    raw: Test,
    selective: Array<out Column<*>>? = null,
    vararg ignore: Column<*>,
  ) {
    val list = if(selective.isNullOrEmpty()) null else selective
    if((list == null || list.contains(title)) && !ignore.contains(title))
      builder[title] = raw.title
    if((list == null || list.contains(status)) && !ignore.contains(status))
      builder[status] = raw.status
    if((list == null || list.contains(description)) && !ignore.contains(description))
      builder[description] = raw.description
    if((list == null || list.contains(status2)) && !ignore.contains(status2))
      builder[status2] = raw.status2
    if((list == null || list.contains(array)) && !ignore.contains(array))
      builder[array] = raw.array
    if((list == null || list.contains(dateTime)) && !ignore.contains(dateTime))
      builder[dateTime] = raw.dateTime
    if((list == null || list.contains(duration)) && !ignore.contains(duration))
      builder[duration] = raw.duration
    if((list == null || list.contains(time)) && !ignore.contains(time))
      builder[time] = raw.time
    if((list == null || list.contains(date)) && !ignore.contains(date))
      builder[date] = raw.date
    if((list == null || list.contains(timestamp)) && !ignore.contains(timestamp))
      builder[timestamp] = raw.timestamp
    if((list == null || list.contains(decimal)) && !ignore.contains(decimal))
      builder[decimal] = raw.decimal
    if((list == null || list.contains(decimalNullable)) && !ignore.contains(decimalNullable))
      builder[decimalNullable] = raw.decimalNullable
    if((list == null || list.contains(uuid)) && !ignore.contains(uuid))
      builder[uuid] = raw.uuid
    if((list == null || list.contains(uuidNullable)) && !ignore.contains(uuidNullable))
      builder[uuidNullable] = raw.uuidNullable
    if((list == null || list.contains(datetime)) && !ignore.contains(datetime))
      builder[datetime] = raw.datetime
    if((list == null || list.contains(datetimeNullable)) && !ignore.contains(datetimeNullable))
      builder[datetimeNullable] = raw.datetimeNullable
    if((list == null || list.contains(id)) && !ignore.contains(id))
      builder[id] = raw.id
  }

  public fun ResultRow.toTest(vararg selective: Column<*>): Test {
    if(selective.isNotEmpty()) {
      return parseRowSelective(this)
    }
    return parseRow(this)
  }

  public fun Iterable<ResultRow>.toTestList(vararg selective: Column<*>): List<Test> = this.map {
    it.toTest(*selective)
  }

  public fun TestTable.selectSlice(vararg selective: Column<*>): Query {
    val query = if(selective.isNotEmpty()) {
      select(selective.toList())
    }
    else {
      selectAll()
    }
    return query
  }

  public fun UpdateBuilder<*>.setValue(raw: Test, vararg ignore: Column<*>): Unit = assign(this, raw, ignore = ignore)

  public fun UpdateBuilder<*>.setValueSelective(raw: Test, vararg selective: Column<*>): Unit = assign(this, raw, selective = selective)

  public fun TestTable.insert(raw: Test): InsertStatement<Number> = insert {
    assign(it, raw)
  }

  public fun TestTable.insertIgnore(raw: Test): InsertStatement<Long> = insertIgnore {
    assign(it, raw)
  }

  public fun TestTable.upsert(
    raw: Test,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): UpsertStatement<Long> = upsert(where = where, onUpdate = onUpdate, onUpdateExclude = onUpdateExclude) {
    assign(it, raw)
  }

  public fun TestTable.batchInsert(
    list: Iterable<Test>,
    ignoreErrors: Boolean = false,
    shouldReturnGeneratedValues: Boolean = false,
  ): List<ResultRow> {
    val rows = batchInsert(list, ignoreErrors, shouldReturnGeneratedValues) {
      entry -> assign(this, entry)
    }
    return rows
  }

  public fun TestTable.batchUpsert(
    list: Iterable<Test>,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    shouldReturnGeneratedValues: Boolean = false,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): List<ResultRow> {
    val rows =  batchUpsert(data = list, keys = arrayOf(id), onUpdate = onUpdate, onUpdateExclude = onUpdateExclude, where = where, shouldReturnGeneratedValues = shouldReturnGeneratedValues) {
      data: Test-> assign(this, data)
    }
    return rows
  }

  public fun TestTable.update(
    raw: Test,
    selective: Array<out Column<*>>? = null,
    ignore: Array<out Column<*>>? = null,
    limit: Int? = null,
    `where`: SqlExpressionBuilder.() -> Op<Boolean>,
  ): Int = update(`where`, limit) {
    val ignoreColumns = ignore ?: arrayOf()
    assign(it, raw, selective = selective, *ignoreColumns)
  }

  public fun TestTable.updateByPrimaryKey(raw: Test, vararg selective: Column<*>): Int = update(raw, selective = selective, ignore = arrayOf(id)) {
    TestTable.id.eq(raw.id)
  }

  public fun TestTable.updateByPrimaryKey(id: Long, builder: TestTable.(UpdateStatement) -> Unit): Int = update({ TestTable.id.eq(id) }, body = builder)

  public fun TestTable.deleteByPrimaryKey(id: Long): Int = deleteWhere {
    TestTable.id.eq(id)
  }

  public fun TestTable.selectByPrimaryKey(id: Long, vararg selective: Column<*>): Test? {
    val query = selectSlice(*selective).andWhere {
      TestTable.id.eq(id)
    }
    return query.firstOrNull()?.toTest(*selective)
  }

  public fun TestTable.selectByPrimaryKeys(ids: Iterable<Long>, vararg selective: Column<*>): List<Test> {
    val query = selectSlice(*selective).andWhere {
      TestTable.id inList ids
    }
    return query.toTestList(*selective)
  }

  public fun TestTable.selectMany(vararg selective: Column<*>, `where`: Query.() -> Query?): List<Test> {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.toTestList(*selective)
  }

  public fun TestTable.selectOne(vararg selective: Column<*>, `where`: Query.() -> Query?): Test? {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.firstOrNull()?.toTest(*selective)
  }

  public fun TestTable.selectForwardByPrimaryKey(
    forwardToken: String? = null,
    order: SortOrder = SortOrder.DESC,
    pageSize: Int = 50,
    selective: Collection<Column<*>> = listOf(),
    `where`: (Query.() -> Query?)? = null,
  ): OffsetList<Test> {
    if(pageSize < 1) {
      return OffsetList.empty()
    }
    val offsetKey = forwardToken?.let { OffsetList.decodeToken(it).firstOrNull()?.ifBlank { null } }
    val query = selectSlice(*selective.toTypedArray())
    offsetKey?.let {
      val keyValue = parseColumnValue(it, id)
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { id less keyValue }
        else-> query.andWhere { id greater keyValue }
      }
    }
    `where`?.invoke(query)
    val sorted = query.orderBy(id, order)
    val list = sorted.limit(pageSize + 1).toTestList(*selective.toTypedArray()).toMutableList()
    val dataCount = list.size
    val token = if(dataCount > pageSize) {
      list.removeLast()
      val idString = list.last().getColumnValueString(id)
      OffsetList.encodeToken(idString)
    }
    else {
      null
    }
    return OffsetList(list, token)
  }

  public fun <T : Comparable<T>> TestTable.selectForward(
    sortColumn: Column<T>,
    forwardToken: String? = null,
    order: SortOrder = SortOrder.DESC,
    pageSize: Int = 50,
    selective: Collection<Column<*>> = listOf(),
    `where`: (Query.() -> Query?)? = null,
  ): OffsetList<Test> {
    if(pageSize < 1) {
      return OffsetList.empty()
    }
    if(sortColumn == id) {
      return this.selectForwardByPrimaryKey(forwardToken, order, pageSize, selective, `where`)
    }
    val kp = forwardToken?.let { if(it.isNotBlank()) OffsetList.decodeToken(it) else null }
    val offsetKey = if(!kp.isNullOrEmpty()) parseColumnValue(kp.first(), sortColumn) else null
    val lastId = if(kp != null && kp.size > 1 && kp[1].isNotBlank()) parseColumnValue(kp[1], id) else null
    val query = selectSlice(*selective.toTypedArray())
    offsetKey?.let {
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { sortColumn lessEq it }
        else-> query.andWhere { sortColumn greaterEq it }
      }
    }
    lastId?.let {
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { id less it }
        else-> query.andWhere { id greater it }
      }
    }
    `where`?.invoke(query)
    val sorted = query.orderBy(Pair(sortColumn, order), Pair(id, order))
    val list = sorted.limit(pageSize + 1).toTestList(*selective.toTypedArray()).toMutableList()
    val dataCount = list.size
    val token = if(dataCount > pageSize) {
      list.removeLast()
      val idToEncode = list.last().getColumnValueString(id)
      val sortKey = list.last().getColumnValueString(sortColumn)
      OffsetList.encodeToken(arrayOf(sortKey, idToEncode))
    }
    else null
    return OffsetList(list, token)
  }

  public fun TestTable.replace(raw: Test): ReplaceStatement<Long> = replace {
    assign(it, raw)
  }
}
